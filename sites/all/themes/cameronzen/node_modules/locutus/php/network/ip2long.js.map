{"version":3,"sources":["../../../src/php/network/ip2long.js"],"names":[],"mappings":";;AAAA,OAAO,OAAP,GAAiB,SAAS,OAAT,CAAkB,KAAlB,EAAyB;;;;;;;;;;;;;;AAcxC,MAAI,IAAI,CAAR;;;;AAIA,MAAM,UAAU,IAAI,MAAJ,CAAW,CACzB,kCADyB,EAEzB,yCAFyB,EAGzB,yCAHyB,EAIzB,0CAJyB,EAKzB,IALyB,CAKpB,EALoB,CAAX,EAKJ,GALI,CAAhB;;AAOA,UAAQ,MAAM,KAAN,CAAY,OAAZ,CAAR,C;AACA,MAAI,CAAC,KAAL,EAAY;;AAEV,WAAO,KAAP;AACD;;AAED,QAAM,CAAN,IAAW,CAAX;AACA,OAAK,IAAI,CAAT,EAAY,IAAI,CAAhB,EAAmB,KAAK,CAAxB,EAA2B;AACzB,UAAM,CAAN,KAAY,CAAC,CAAE,CAAC,MAAM,CAAN,KAAY,EAAb,EAAiB,MAAhC;AACA,UAAM,CAAN,IAAW,SAAS,MAAM,CAAN,CAAT,KAAsB,CAAjC;AACD;;;AAGD,QAAM,IAAN,CAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B;;AAEA,QAAM,IAAI,MAAM,CAAN,CAAV,KAAuB,KAAK,GAAL,CAAS,GAAT,EAAc,IAAI,MAAM,CAAN,CAAlB,CAAvB;AACA,MAAI,MAAM,CAAN,KAAY,MAAM,CAAN,CAAZ,IACF,MAAM,CAAN,KAAY,MAAM,CAAN,CADV,IAEF,MAAM,CAAN,KAAY,MAAM,CAAN,CAFV,IAGF,MAAM,CAAN,KAAY,MAAM,CAAN,CAHd,EAGwB;AACtB,WAAO,KAAP;AACD;;AAED,SAAO,MAAM,CAAN,KAAY,MAAM,CAAN,MAAa,CAAb,IAAkB,QAA9B,IACL,MAAM,CAAN,KAAY,MAAM,CAAN,KAAY,CAAZ,IAAiB,KAA7B,CADK,GAEL,MAAM,CAAN,KAAY,MAAM,CAAN,KAAY,CAAZ,IAAiB,GAA7B,CAFK,GAGL,MAAM,CAAN,IAAW,CAHb;AAID,CApDD","file":"ip2long.js","sourcesContent":["module.exports = function ip2long (argIP) {\n  //  discuss at: http://locutus.io/php/ip2long/\n  // original by: Waldo Malqui Silva (http://waldo.malqui.info)\n  // improved by: Victor\n  //  revised by: fearphage (http://http/my.opera.com/fearphage/)\n  //  revised by: Theriault (https://github.com/Theriault)\n  //    estarget: es2015\n  //   example 1: ip2long('192.0.34.166')\n  //   returns 1: 3221234342\n  //   example 2: ip2long('0.0xABCDEF')\n  //   returns 2: 11259375\n  //   example 3: ip2long('255.255.255.256')\n  //   returns 3: false\n\n  let i = 0\n  // PHP allows decimal, octal, and hexadecimal IP components.\n  // PHP allows between 1 (e.g. 127) to 4 (e.g 127.0.0.1) components.\n\n  const pattern = new RegExp([\n    '^([1-9]\\\\d*|0[0-7]*|0x[\\\\da-f]+)',\n    '(?:\\\\.([1-9]\\\\d*|0[0-7]*|0x[\\\\da-f]+))?',\n    '(?:\\\\.([1-9]\\\\d*|0[0-7]*|0x[\\\\da-f]+))?',\n    '(?:\\\\.([1-9]\\\\d*|0[0-7]*|0x[\\\\da-f]+))?$'\n  ].join(''), 'i')\n\n  argIP = argIP.match(pattern) // Verify argIP format.\n  if (!argIP) {\n    // Invalid format.\n    return false\n  }\n  // Reuse argIP variable for component counter.\n  argIP[0] = 0\n  for (i = 1; i < 5; i += 1) {\n    argIP[0] += !!((argIP[i] || '').length)\n    argIP[i] = parseInt(argIP[i]) || 0\n  }\n  // Continue to use argIP for overflow values.\n  // PHP does not allow any component to overflow.\n  argIP.push(256, 256, 256, 256)\n  // Recalculate overflow of last component supplied to make up for missing components.\n  argIP[4 + argIP[0]] *= Math.pow(256, 4 - argIP[0])\n  if (argIP[1] >= argIP[5] ||\n    argIP[2] >= argIP[6] ||\n    argIP[3] >= argIP[7] ||\n    argIP[4] >= argIP[8]) {\n    return false\n  }\n\n  return argIP[1] * (argIP[0] === 1 || 16777216) +\n    argIP[2] * (argIP[0] <= 2 || 65536) +\n    argIP[3] * (argIP[0] <= 3 || 256) +\n    argIP[4] * 1\n}\n"]}