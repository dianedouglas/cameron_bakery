{"version":3,"sources":["../../../src/php/json/json_decode.js"],"names":[],"mappings":";;;;AAAA,OAAO,OAAP,GAAiB,SAAS,WAAT,CAAsB,OAAtB,EAA+B;;;;;;;;;;;;;;;;;;;;;AAoB9C,MAAI,UAAW,OAAO,MAAP,KAAkB,WAAlB,GAAgC,MAAhC,GAAyC,MAAxD;AACA,UAAQ,QAAR,GAAmB,QAAQ,QAAR,IAAoB,EAAvC;AACA,MAAI,WAAW,QAAQ,QAAvB;AACA,WAAS,GAAT,GAAe,SAAS,GAAT,IAAgB,EAA/B;;AAEA,MAAI,OAAO,QAAQ,IAAnB;AACA,MAAI,QAAO,IAAP,yCAAO,IAAP,OAAgB,QAAhB,IAA4B,OAAO,KAAK,KAAZ,KAAsB,UAAtD,EAAkE;AAChE,QAAI;AACF,aAAO,KAAK,KAAL,CAAW,OAAX,CAAP;AACD,KAFD,CAEE,OAAO,GAAP,EAAY;AACZ,UAAI,EAAE,eAAe,WAAjB,CAAJ,EAAmC;AACjC,cAAM,IAAI,KAAJ,CAAU,wCAAV,CAAN;AACD;;;AAGD,eAAS,GAAT,CAAa,eAAb,GAA+B,CAA/B;AACA,aAAO,IAAP;AACD;AACF;;AAED,MAAI,QAAQ,CACV,QADU,EAEV,GAFU,EAGV,KAHU,EAIV,GAJU,EAKV,GALU,EAMV,GANU,EAOV,KAPU,EAQV,UARU,EASV,KATU,EAUV,GAVU,EAWV,KAXU,EAYV,IAZU,CAYL,EAZK,CAAZ;AAaA,MAAI,KAAK,IAAI,MAAJ,CAAW,MAAM,KAAN,GAAc,GAAzB,EAA8B,GAA9B,CAAT;AACA,MAAI,CAAJ;AACA,MAAI,OAAO,OAAX;;;;;AAKA,KAAG,SAAH,GAAe,CAAf;AACA,MAAI,GAAG,IAAH,CAAQ,IAAR,CAAJ,EAAmB;AACjB,WAAO,KAAK,OAAL,CAAa,EAAb,EAAiB,UAAU,CAAV,EAAa;AACnC,aAAO,QAAQ,CAAC,SAAS,EAAE,UAAF,CAAa,CAAb,EACtB,QADsB,CACb,EADa,CAAV,EAEZ,KAFY,CAEN,CAAC,CAFK,CAAf;AAGD,KAJM,CAAP;AAKD;;;;;;;;;;;;;;AAcD,MAAI,IAAK,eAAD,CACL,IADK,CACA,KAAK,OAAL,CAAa,qCAAb,EAAoD,GAApD,EACL,OADK,CACG,kEADH,EACuE,GADvE,EAEL,OAFK,CAEG,sBAFH,EAE2B,EAF3B,CADA,CAAR;;AAKA,MAAI,CAAJ,EAAO;;;;;AAKL,QAAI,KAAK,MAAM,IAAN,GAAa,GAAlB,CAAJ,C;AACA,WAAO,CAAP;AACD;;;AAGD,WAAS,GAAT,CAAa,eAAb,GAA+B,CAA/B;AACA,SAAO,IAAP;AACD,CAlGD","file":"json_decode.js","sourcesContent":["module.exports = function json_decode (strJson) { // eslint-disable-line camelcase\n  //       discuss at: http://phpjs.org/functions/json_decode/\n  //      original by: Public Domain (http://www.json.org/json2.js)\n  // reimplemented by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  //      improved by: T.J. Leahy\n  //      improved by: Michael White\n  //           note 1: If node or the browser does not offer JSON.parse,\n  //           note 1: this function falls backslash\n  //           note 1: to its own implementation using eval, and hence should be considered unsafe\n  //        example 1: json_decode('[ 1 ]')\n  //        returns 1: [1]\n\n  /*\n    http://www.JSON.org/json2.js\n    2008-11-19\n    Public Domain.\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n    See http://www.JSON.org/js.html\n  */\n\n  var $global = (typeof window !== 'undefined' ? window : global)\n  $global.$locutus = $global.$locutus || {}\n  var $locutus = $global.$locutus\n  $locutus.php = $locutus.php || {}\n\n  var json = $global.JSON\n  if (typeof json === 'object' && typeof json.parse === 'function') {\n    try {\n      return json.parse(strJson)\n    } catch (err) {\n      if (!(err instanceof SyntaxError)) {\n        throw new Error('Unexpected error type in json_decode()')\n      }\n\n      // usable by json_last_error()\n      $locutus.php.last_error_json = 4\n      return null\n    }\n  }\n\n  var chars = [\n    '\\u0000',\n    '\\u00ad',\n    '\\u0600-\\u0604',\n    '\\u070f',\n    '\\u17b4',\n    '\\u17b5',\n    '\\u200c-\\u200f',\n    '\\u2028-\\u202f',\n    '\\u2060-\\u206f',\n    '\\ufeff',\n    '\\ufff0-\\uffff'\n  ].join('')\n  var cx = new RegExp('[' + chars + ']', 'g')\n  var j\n  var text = strJson\n\n  // Parsing happens in four stages. In the first stage, we replace certain\n  // Unicode characters with escape sequences. JavaScript handles many characters\n  // incorrectly, either silently deleting them, or treating them as line endings.\n  cx.lastIndex = 0\n  if (cx.test(text)) {\n    text = text.replace(cx, function (a) {\n      return '\\\\u' + ('0000' + a.charCodeAt(0)\n        .toString(16))\n        .slice(-4)\n    })\n  }\n\n  // In the second stage, we run the text against regular expressions that look\n  // for non-JSON patterns. We are especially concerned with '()' and 'new'\n  // because they can cause invocation, and '=' because it can cause mutation.\n  // But just to be safe, we want to reject all unexpected forms.\n  // We split the second stage into 4 regexp operations in order to work around\n  // crippling inefficiencies in IE's and Safari's regexp engines. First we\n  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\n  // replace all simple value tokens with ']' characters. Third, we delete all\n  // open brackets that follow a colon or comma or that begin the text. Finally,\n  // we look to see that the remaining characters are only whitespace or ']' or\n  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\n\n  var m = (/^[\\],:{}\\s]*$/)\n    .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\n    .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\n    .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))\n\n  if (m) {\n    // In the third stage we use the eval function to compile the text into a\n    // JavaScript structure. The '{' operator is subject to a syntactic ambiguity\n    // in JavaScript: it can begin a block or an object literal. We wrap the text\n    // in parens to eliminate the ambiguity.\n    j = eval('(' + text + ')') // eslint-disable-line no-eval\n    return j\n  }\n\n  // usable by json_last_error()\n  $locutus.php.last_error_json = 4\n  return null\n}\n"]}