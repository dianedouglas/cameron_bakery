{"version":3,"sources":["../../../src/php/bc/bcround.js"],"names":[],"mappings":";;AAAA,OAAO,OAAP,GAAiB,SAAS,OAAT,CAAkB,GAAlB,EAAuB,SAAvB,EAAkC;;;;;;AAMjD,MAAI,MAAM,QAAQ,iBAAR,CAAV;AACA,MAAI,YAAY,KAAhB;;AAEA,MAAI,IAAJ,EAAU,MAAV,EAAkB,KAAlB;AACA,MAAI,YAAJ;;;AAGA,SAAO,UAAU,WAAV,EAAP;AACA,SAAO,UAAU,WAAV,CAAsB,IAAI,QAAJ,EAAtB,CAAP;;;AAGA,MAAI,aAAa,KAAK,OAAtB,EAA+B;;AAE7B,WAAO,KAAK,OAAL,GAAe,SAAtB,EAAiC;AAC/B,WAAK,OAAL,CAAa,KAAK,KAAL,GAAa,KAAK,OAA/B,IAA0C,CAA1C;AACA,WAAK,OAAL;AACD;AACD,WAAO,KAAK,QAAL,EAAP;AACD;;;;AAID,UAAQ,KAAK,OAAL,CAAa,KAAK,KAAL,GAAa,SAA1B,CAAR;;AAEA,iBAAe,UAAU,WAAV,EAAf;AACA,iBAAe,UAAU,UAAV,CAAqB,CAArB,EAAwB,SAAxB,CAAf;;AAEA,MAAI,SAAS,CAAb,EAAgB;;;AAGd,iBAAa,OAAb,CAAqB,aAAa,KAAb,GAAqB,aAAa,OAAlC,GAA4C,CAAjE,IAAsE,CAAtE;AACA,QAAI,KAAK,MAAL,KAAgB,UAAU,KAA9B,EAAqC;;AAEnC,mBAAa,MAAb,GAAsB,UAAU,KAAhC;AACD;AACD,aAAS,UAAU,MAAV,CAAiB,IAAjB,EAAuB,YAAvB,EAAqC,SAArC,CAAT;AACD,GATD,MASO;;AAEL,aAAS,IAAT;AACD;;AAED,MAAI,OAAO,OAAP,GAAiB,SAArB,EAAgC;AAC9B,WAAO,OAAP,GAAiB,SAAjB;AACD;;AAED,SAAO,OAAO,QAAP,EAAP;AACD,CApDD","file":"bcround.js","sourcesContent":["module.exports = function bcround (val, precision) {\n  //  discuss at: http://locutus.io/php/bcround/\n  // original by: lmeyrick (https://sourceforge.net/projects/bcmath-js/)\n  //   example 1: bcround(1, 2)\n  //   returns 1: '1.00'\n\n  var _bc = require('../_helpers/_bc')\n  var libbcmath = _bc()\n\n  var temp, result, digit\n  var rightOperand\n\n  // create number\n  temp = libbcmath.bc_init_num()\n  temp = libbcmath.php_str2num(val.toString())\n\n  // check if any rounding needs\n  if (precision >= temp.n_scale) {\n    // nothing to round, just add the zeros.\n    while (temp.n_scale < precision) {\n      temp.n_value[temp.n_len + temp.n_scale] = 0\n      temp.n_scale++\n    }\n    return temp.toString()\n  }\n\n  // get the digit we are checking (1 after the precision)\n  // loop through digits after the precision marker\n  digit = temp.n_value[temp.n_len + precision]\n\n  rightOperand = libbcmath.bc_init_num()\n  rightOperand = libbcmath.bc_new_num(1, precision)\n\n  if (digit >= 5) {\n    // round away from zero by adding 1 (or -1) at the \"precision\"..\n    // ie 1.44999 @ 3dp = (1.44999 + 0.001).toString().substr(0,5)\n    rightOperand.n_value[rightOperand.n_len + rightOperand.n_scale - 1] = 1\n    if (temp.n_sign === libbcmath.MINUS) {\n      // round down\n      rightOperand.n_sign = libbcmath.MINUS\n    }\n    result = libbcmath.bc_add(temp, rightOperand, precision)\n  } else {\n    // leave-as-is.. just truncate it.\n    result = temp\n  }\n\n  if (result.n_scale > precision) {\n    result.n_scale = precision\n  }\n\n  return result.toString()\n}\n"]}