{"version":3,"sources":["../../../src/php/strings/sscanf.js"],"names":[],"mappings":";;AAAA,OAAO,OAAP,GAAiB,SAAS,MAAT,CAAiB,GAAjB,EAAsB,MAAtB,EAA8B;;;;;;;;;;;;AAY7C,MAAI,SAAS,EAAb;AACA,MAAI,OAAO,IAAX;AACA,MAAI,OAAO,SAAX;AACA,MAAI,KAAJ;;AAEA,MAAI,2BAA2B,SAA3B,wBAA2B,CAAU,MAAV,EAAkB;;;;;;;;;;AAU/C,QAAI,UAAU,OAAO,KAAP,CAAa,MAAb,EAAqB,KAArB,CAA2B,iBAA3B,CAAd;;AAEA,QAAI,OAAJ,EAAa;AACX,UAAI,OAAO,QAAQ,MAAnB;AACA,aAAO,MAAP,EAAe;AACb,eAAO,IAAP,CAAY,IAAZ;AACD;AACF;AACD,WAAO,SAAP;AACD,GAnBD;;AAqBA,MAAI,UAAU,SAAV,OAAU,GAAY;AACxB,QAAI,KAAK,MAAL,KAAgB,CAApB,EAAuB;AACrB,aAAO,MAAP;AACD;AACD,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,OAAO,MAA3B,EAAmC,EAAE,CAArC,EAAwC;AACtC,WAAK,IAAI,CAAT,EAAY,KAAZ,GAAoB,OAAO,CAAP,CAApB;AACD;AACD,WAAO,CAAP;AACD,GARD;;AAUA,MAAI,WAAW,SAAX,QAAW,CAAU,CAAV,EAAa,KAAb,EAAoB,EAApB,EAAwB;AACrC,QAAI,MAAJ,EAAY;AACV,UAAI,YAAY,IAAI,KAAJ,CAAU,CAAV,CAAhB;AACA,UAAI,QAAQ,QAAQ,UAAU,MAAV,CAAiB,CAAjB,EAAoB,KAApB,CAAR,GAAqC,SAAjD;AACA,UAAI,QAAQ,MAAM,IAAN,CAAW,KAAX,CAAZ;;AAEA,UAAI,MAAM,UAAU,SAAV,GACN,KADM,GAEN,OAAO,MAFX;AAGA,UAAI,WAAW,OAAO,GAAP,IAAc,QACtB,KACC,GAAG,KAAH,CAAS,IAAT,EAAe,KAAf,CADD,GAEC,MAAM,CAAN,CAHqB,GAIvB,IAJN;AAKA,UAAI,aAAa,IAAjB,EAAuB;AACrB,cAAM,IAAI,KAAJ,CAAU,oBAAV,CAAN;AACD;AACD,aAAO,IAAI,MAAM,CAAN,EAAS,MAApB;AACD;AACD,WAAO,CAAP;AACD,GApBD;;AAsBA,MAAI,UAAU,MAAV,GAAmB,CAAvB,EAA0B;AACxB,UAAM,IAAI,KAAJ,CAAU,uCAAV,CAAN;AACD;;;AAGD,OAAK,IAAI,IAAI,CAAR,EAAW,IAAI,CAApB,EAAuB,IAAI,OAAO,MAAlC,EAA0C,GAA1C,EAA+C;AAC7C,QAAI,QAAQ,CAAZ;AACA,QAAI,SAAS,IAAb;;AAEA,QAAI,OAAO,MAAP,CAAc,CAAd,MAAqB,GAAzB,EAA8B;AAC5B,UAAI,OAAO,MAAP,CAAc,IAAI,CAAlB,MAAyB,GAA7B,EAAkC;AAChC,YAAI,IAAI,MAAJ,CAAW,CAAX,MAAkB,GAAtB,EAA2B;;;AAGzB,YAAE,CAAF;AACA,YAAE,CAAF;AACA;AACD;;AAED,eAAO,yBAAyB,IAAI,CAA7B,CAAP;AACD;;;;;AAKD,UAAI,aAAa,IAAI,MAAJ,CAAW,qCAAX,EAAkD,GAAlD,CAAjB;;AAEA,UAAI,WAAW,WAAW,IAAX,CAAgB,OAAO,KAAP,CAAa,IAAI,CAAjB,CAAhB,CAAf;;AAEA,UAAI,WAAW,KAAf;AACA,UAAI,YAAY,SAAS,CAAT,MAAgB,SAAhC,EAA2C;AACzC,YAAI,MAAM,yDAAV;AACA,eAAO,4BAAP;AACA,cAAM,IAAI,KAAJ,CAAU,GAAV,CAAN;AACD;AACD,cAAQ,SAAS,CAAT,IAAc,SAAS,SAAS,CAAT,CAAT,EAAsB,EAAtB,IAA4B,CAA1C,GAA8C,SAAtD;;AAEA,eAAS,CAAC,SAAS,CAAT,CAAV;AACA,cAAQ,SAAS,SAAS,CAAT,CAAT,EAAsB,EAAtB,CAAR;AACA,UAAI,WAAW,SAAS,CAAT,CAAf;AACA,WAAK,WAAW,SAAhB;;;AAGA,UAAI,QAAJ,EAAc;;AAEZ,gBAAQ,QAAR;AACE,eAAK,GAAL;AACA,eAAK,GAAL;AACA,eAAK,GAAL;;;;;AAKE;AACF;AACE,kBAAM,IAAI,KAAJ,CAAU,wCAAV,CAAN;AAVJ;AAYD;;AAED,UAAI;;;;;AAKF,gBAAQ,OAAO,MAAP,CAAc,IAAI,CAAlB,CAAR;AACE,eAAK,GAAL;;;;AAIE;AACF,eAAK,GAAL;;;AAGE;AACF,eAAK,GAAL;;;AAGE;AACF,eAAK,GAAL;;;;AAIE;AACF,eAAK,GAAL;;AAEE,gBAAI,UAAU,oDAAd;AACA,gBAAI,SAAS,CAAT,EAAY,OAAZ,EAAqB,UAAU,GAAV,EAAe,IAAf,EAAqB,GAArB,EACzB,GADyB,EACpB,GADoB,EACf;AACR,qBAAO,MAAM,SAAS,GAAT,EAAc,EAAd,CAAN,GAA0B,MAAM,SAAS,GAAT,EAAc,CAAd,CAAN,GAAyB,SAAS,GAAT,EAAc,EAAd,CAA1D;AACD,aAHG,CAAJ;AAIA;AACF,eAAK,GAAL;;AAEE,mBAAO,UAAU,SAAV,GAAsB,KAAtB,GAA8B,OAAO,MAAP,GAAgB,CAArD,IAA0D,CAA1D;AACA;;AAEF,eAAK,GAAL;;;;AAIE,gBAAI,SAAS,CAAT,EAAY,IAAI,MAAJ,CAAW,UAAU,SAAS,CAAnB,IAAwB,GAAnC,CAAZ,CAAJ;AACA;AACF,eAAK,GAAL;AACA,eAAK,GAAL;;;AAGE,gBAAI,SAAS,CAAT,EAAY,oBAAZ,EAAkC,UAAU,GAAV,EAAe,IAAf,EAAqB,GAArB,EAA0B;;AAE9D,kBAAI,SAAS,SAAS,CAAC,QAAQ,EAAT,IAAe,GAAxB,EAA6B,EAA7B,CAAb;AACA,kBAAI,SAAS,CAAb,EAAgB;;;AAGd,uBAAO,SAAS,CAAC,UAAV,GAAuB,CAAC,UAAxB,GAAqC,MAA5C;AACD,eAJD,MAIO;;AAEL,uBAAO,SAAS,UAAT,GAAsB,MAAtB,GAA+B,UAAtC;AACD;AACF,aAXG,CAAJ;AAYA;AACF,eAAK,GAAL;AACA,eAAK,GAAL;AACA,eAAK,GAAL;;;;AAIE,gBAAI,SAAS,CAAT,EAAY,uCAAZ,EAAqD,UAAU,GAAV,EAAe,IAAf,EAAqB,GAArB,EAA0B;AACjF,kBAAI,QAAQ,GAAZ,EAAiB;AACf,uBAAO,IAAP;AACD;;AAED,qBAAO,WAAW,CAAC,QAAQ,EAAT,IAAe,GAA1B,CAAP;AACD,aANG,CAAJ;AAOA;AACF,eAAK,GAAL;;;AAGE,gBAAI,SAAS,CAAT,EAAY,oBAAZ,EAAkC,UAAU,GAAV,EAAe,IAAf,EAAqB,GAArB,EAA0B;;AAE9D,kBAAI,SAAS,SAAS,GAAT,EAAc,EAAd,CAAb;AACA,kBAAI,SAAS,GAAb,EAAkB;;;AAGhB,uBAAO,aAAa,MAApB;AACD,eAJD,MAIO;AACL,uBAAO,SAAS,UAAT,GAAsB,MAAtB,GAA+B,UAAtC;AACD;AACF,aAVG,CAAJ;AAWA;AACF,eAAK,GAAL;;AAEE,gBAAI,SAAS,CAAT,EAAY,sBAAZ,EAAoC,UAAU,GAAV,EAAe,IAAf,EAAqB,GAArB,EAA0B;AAChE,qBAAO,SAAS,GAAT,EAAc,CAAd,CAAP;AACD,aAFG,CAAJ;AAGA;AACF,eAAK,GAAL;;AAEE,gBAAI,SAAS,CAAT,EAAY,KAAZ,CAAJ;AACA;AACF,eAAK,GAAL;AACA,eAAK,GAAL;;;;AAIE,gBAAI,SAAS,CAAT,EAAY,iCAAZ,EAA+C,UAAU,GAAV,EAAe,IAAf,EAAqB,GAArB,EAA0B;AAC3E,qBAAO,SAAS,GAAT,EAAc,EAAd,CAAP;AACD,aAFG,CAAJ;AAGA;AACF,eAAK,EAAL;;AAEE,kBAAM,IAAI,KAAJ,CAAU,kEAAV,CAAN;AACF;AACE,kBAAM,IAAI,KAAJ,CAAU,uEAAV,CAAN;AA3GJ;AA6GD,OAlHD,CAkHE,OAAO,CAAP,EAAU;AACV,YAAI,MAAM,oBAAV,EAAgC;;AAE9B,iBAAO,yBAAyB,IAAI,CAA7B,CAAP;AACD;;AAEF;AACD,QAAE,CAAF;AACD,KA5KD,MA4KO,IAAI,OAAO,MAAP,CAAc,CAAd,MAAqB,IAAI,MAAJ,CAAW,CAAX,CAAzB,EAAwC;;AAE7C,WAAK,SAAL,GAAiB,CAAjB;AACA,UAAK,IAAD,CACD,IADC,CACI,IAAI,MAAJ,CAAW,CAAX,CADJ,KACsB,IAAI,MAAJ,CAAW,CAAX,MAAkB,EAD5C,EACgD;;AAE9C,eAAO,yBAAyB,IAAI,CAA7B,CAAP;AACD,OAJD,MAIO;;;;AAIL,cAAM,IAAI,KAAJ,CAAU,CAAV,EAAa,CAAb,IAAkB,IAAI,KAAJ,CAAU,IAAI,CAAd,CAAxB;AACA;AACD;AACF,KAdM,MAcA;AACL;AACD;AACF;;;AAGD,SAAO,SAAP;AACD,CAhRD","file":"sscanf.js","sourcesContent":["module.exports = function sscanf (str, format) {\n  //  discuss at: http://locutus.io/php/sscanf/\n  // original by: Brett Zamir (http://brett-zamir.me)\n  //   example 1: sscanf('SN/2350001', 'SN/%d')\n  //   returns 1: [2350001]\n  //   example 2: var myVar = {}\n  //   example 2: sscanf('SN/2350001', 'SN/%d', myVar)\n  //   example 2: var $result = myVar.value\n  //   returns 2: 2350001\n  //   example 3: sscanf(\"10--20\", \"%2$d--%1$d\") // Must escape '$' in PHP, but not JS\n  //   returns 3: [20, 10]\n\n  var retArr = []\n  var _NWS = /\\S/\n  var args = arguments\n  var digit\n\n  var _setExtraConversionSpecs = function (offset) {\n    // Since a mismatched character sets us off track from future\n    // legitimate finds, we just scan\n    // to the end for any other conversion specifications (besides a percent literal),\n    // setting them to null\n    // sscanf seems to disallow all conversion specification components (of sprintf)\n    // except for type specifiers\n    // Do not allow % in last char. class\n    // var matches = format.match(/%[+-]?([ 0]|'.)?-?\\d*(\\.\\d+)?[bcdeufFosxX]/g);\n    // Do not allow % in last char. class:\n    var matches = format.slice(offset).match(/%[cdeEufgosxX]/g)\n    // b, F,G give errors in PHP, but 'g', though also disallowed, doesn't\n    if (matches) {\n      var lgth = matches.length\n      while (lgth--) {\n        retArr.push(null)\n      }\n    }\n    return _finish()\n  }\n\n  var _finish = function () {\n    if (args.length === 2) {\n      return retArr\n    }\n    for (var i = 0; i < retArr.length; ++i) {\n      args[i + 2].value = retArr[i]\n    }\n    return i\n  }\n\n  var _addNext = function (j, regex, cb) {\n    if (assign) {\n      var remaining = str.slice(j)\n      var check = width ? remaining.substr(0, width) : remaining\n      var match = regex.exec(check)\n      // @todo: Make this more readable\n      var key = digit !== undefined\n        ? digit\n        : retArr.length\n      var testNull = retArr[key] = match\n          ? (cb\n            ? cb.apply(null, match)\n            : match[0])\n          : null\n      if (testNull === null) {\n        throw new Error('No match in string')\n      }\n      return j + match[0].length\n    }\n    return j\n  }\n\n  if (arguments.length < 2) {\n    throw new Error('Not enough arguments passed to sscanf')\n  }\n\n  // PROCESS\n  for (var i = 0, j = 0; i < format.length; i++) {\n    var width = 0\n    var assign = true\n\n    if (format.charAt(i) === '%') {\n      if (format.charAt(i + 1) === '%') {\n        if (str.charAt(j) === '%') {\n          // a matched percent literal\n          // skip beyond duplicated percent\n          ++i\n          ++j\n          continue\n        }\n        // Format indicated a percent literal, but not actually present\n        return _setExtraConversionSpecs(i + 2)\n      }\n\n      // CHARACTER FOLLOWING PERCENT IS NOT A PERCENT\n\n      // We need 'g' set to get lastIndex\n      var prePattern = new RegExp('^(?:(\\\\d+)\\\\$)?(\\\\*)?(\\\\d*)([hlL]?)', 'g')\n\n      var preConvs = prePattern.exec(format.slice(i + 1))\n\n      var tmpDigit = digit\n      if (tmpDigit && preConvs[1] === undefined) {\n        var msg = 'All groups in sscanf() must be expressed as numeric if '\n        msg += 'any have already been used'\n        throw new Error(msg)\n      }\n      digit = preConvs[1] ? parseInt(preConvs[1], 10) - 1 : undefined\n\n      assign = !preConvs[2]\n      width = parseInt(preConvs[3], 10)\n      var sizeCode = preConvs[4]\n      i += prePattern.lastIndex\n\n      // @todo: Does PHP do anything with these? Seems not to matter\n      if (sizeCode) {\n        // This would need to be processed later\n        switch (sizeCode) {\n          case 'h':\n          case 'l':\n          case 'L':\n            // Treats subsequent as short int (for d,i,n) or unsigned short int (for o,u,x)\n            // Treats subsequent as long int (for d,i,n), or unsigned long int (for o,u,x);\n            //    or as double (for e,f,g) instead of float or wchar_t instead of char\n            // Treats subsequent as long double (for e,f,g)\n            break\n          default:\n            throw new Error('Unexpected size specifier in sscanf()!')\n        }\n      }\n      // PROCESS CHARACTER\n      try {\n        // For detailed explanations, see http://web.archive.org/web/20031128125047/http://www.uwm.edu/cgi-bin/IMT/wwwman?topic=scanf%283%29&msection=\n        // Also http://www.mathworks.com/access/helpdesk/help/techdoc/ref/sscanf.html\n        // p, S, C arguments in C function not available\n        // DOCUMENTED UNDER SSCANF\n        switch (format.charAt(i + 1)) {\n          case 'F':\n            // Not supported in PHP sscanf; the argument is treated as a float, and\n            //  presented as a floating-point number (non-locale aware)\n            // sscanf doesn't support locales, so no need for two (see %f)\n            break\n          case 'g':\n            // Not supported in PHP sscanf; shorter of %e and %f\n            // Irrelevant to input conversion\n            break\n          case 'G':\n            // Not supported in PHP sscanf; shorter of %E and %f\n            // Irrelevant to input conversion\n            break\n          case 'b':\n            // Not supported in PHP sscanf; the argument is treated as an integer,\n            // and presented as a binary number\n            // Not supported - couldn't distinguish from other integers\n            break\n          case 'i':\n            // Integer with base detection (Equivalent of 'd', but base 0 instead of 10)\n            var pattern = /([+-])?(?:(?:0x([\\da-fA-F]+))|(?:0([0-7]+))|(\\d+))/\n            j = _addNext(j, pattern, function (num, sign, hex,\n            oct, dec) {\n              return hex ? parseInt(num, 16) : oct ? parseInt(num, 8) : parseInt(num, 10)\n            })\n            break\n          case 'n':\n            // Number of characters processed so far\n            retArr[digit !== undefined ? digit : retArr.length - 1] = j\n            break\n            // DOCUMENTED UNDER SPRINTF\n          case 'c':\n            // Get character; suppresses skipping over whitespace!\n            // (but shouldn't be whitespace in format anyways, so no difference here)\n            // Non-greedy match\n            j = _addNext(j, new RegExp('.{1,' + (width || 1) + '}'))\n            break\n          case 'D':\n          case 'd':\n            // sscanf documented decimal number; equivalent of 'd';\n            // Optionally signed decimal integer\n            j = _addNext(j, /([+-])?(?:0*)(\\d+)/, function (num, sign, dec) {\n              // Ignores initial zeroes, unlike %i and parseInt()\n              var decInt = parseInt((sign || '') + dec, 10)\n              if (decInt < 0) {\n                // PHP also won't allow less than -2147483648\n                // integer overflow with negative\n                return decInt < -2147483648 ? -2147483648 : decInt\n              } else {\n                // PHP also won't allow greater than -2147483647\n                return decInt < 2147483647 ? decInt : 2147483647\n              }\n            })\n            break\n          case 'f':\n          case 'E':\n          case 'e':\n            // Although sscanf doesn't support locales,\n            // this is used instead of '%F'; seems to be same as %e\n            // These don't discriminate here as both allow exponential float of either case\n            j = _addNext(j, /([+-])?(?:0*)(\\d*\\.?\\d*(?:[eE]?\\d+)?)/, function (num, sign, dec) {\n              if (dec === '.') {\n                return null\n              }\n              // Ignores initial zeroes, unlike %i and parseFloat()\n              return parseFloat((sign || '') + dec)\n            })\n            break\n          case 'u':\n            // unsigned decimal integer\n            // We won't deal with integer overflows due to signs\n            j = _addNext(j, /([+-])?(?:0*)(\\d+)/, function (num, sign, dec) {\n              // Ignores initial zeroes, unlike %i and parseInt()\n              var decInt = parseInt(dec, 10)\n              if (sign === '-') {\n                // PHP also won't allow greater than 4294967295\n                // integer overflow with negative\n                return 4294967296 - decInt\n              } else {\n                return decInt < 4294967295 ? decInt : 4294967295\n              }\n            })\n            break\n          case 'o':\n              // Octal integer // @todo: add overflows as above?\n            j = _addNext(j, /([+-])?(?:0([0-7]+))/, function (num, sign, oct) {\n              return parseInt(num, 8)\n            })\n            break\n          case 's':\n            // Greedy match\n            j = _addNext(j, /\\S+/)\n            break\n          case 'X':\n          case 'x':\n          // Same as 'x'?\n            // @todo: add overflows as above?\n            // Initial 0x not necessary here\n            j = _addNext(j, /([+-])?(?:(?:0x)?([\\da-fA-F]+))/, function (num, sign, hex) {\n              return parseInt(num, 16)\n            })\n            break\n          case '':\n            // If no character left in expression\n            throw new Error('Missing character after percent mark in sscanf() format argument')\n          default:\n            throw new Error('Unrecognized character after percent mark in sscanf() format argument')\n        }\n      } catch (e) {\n        if (e === 'No match in string') {\n          // Allow us to exit\n          return _setExtraConversionSpecs(i + 2)\n        }\n        // Calculate skipping beyond initial percent too\n      }\n      ++i\n    } else if (format.charAt(i) !== str.charAt(j)) {\n        // @todo: Double-check i whitespace ignored in string and/or formats\n      _NWS.lastIndex = 0\n      if ((_NWS)\n        .test(str.charAt(j)) || str.charAt(j) === '') {\n        // Whitespace doesn't need to be an exact match)\n        return _setExtraConversionSpecs(i + 1)\n      } else {\n        // Adjust strings when encounter non-matching whitespace,\n        // so they align in future checks above\n        // Ok to replace with j++;?\n        str = str.slice(0, j) + str.slice(j + 1)\n        i--\n      }\n    } else {\n      j++\n    }\n  }\n\n  // POST-PROCESSING\n  return _finish()\n}\n"]}