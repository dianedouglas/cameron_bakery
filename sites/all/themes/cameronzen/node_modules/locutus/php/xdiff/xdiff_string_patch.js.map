{"version":3,"sources":["../../../src/php/xdiff/xdiff_string_patch.js"],"names":[],"mappings":"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","file":"xdiff_string_patch.js","sourcesContent":["module.exports = function xdiff_string_patch (originalStr, patch, flags, errorObj) { // eslint-disable-line camelcase\n  //  discuss at: http://locutus.io/php/xdiff_string_patch/\n  // original by: Brett Zamir (http://brett-zamir.me)\n  // improved by: Steven Levithan (stevenlevithan.com)\n  //      note 1: The XDIFF_PATCH_IGNORESPACE flag and the error argument are not\n  //      note 1: currently supported.\n  //      note 2: This has not been tested exhaustively yet.\n  //      note 3: The errorObj parameter (optional) if used must be passed in as a\n  //      note 3: object. The errors will then be written by reference into it's `value` property\n  //   example 1: xdiff_string_patch('', '@@ -0,0 +1,1 @@\\n+Hello world!')\n  //   returns 1: 'Hello world!'\n\n  // First two functions were adapted from Steven Levithan, also under an MIT license\n  // Adapted from XRegExp 1.5.0\n  // (c) 2007-2010 Steven Levithan\n  // MIT License\n  // <http://xregexp.com>\n\n  var _getNativeFlags = function (regex) {\n    // Proposed for ES4; included in AS3\n    return [\n      (regex.global ? 'g' : ''),\n      (regex.ignoreCase ? 'i' : ''),\n      (regex.multiline ? 'm' : ''),\n      (regex.extended ? 'x' : ''),\n      (regex.sticky ? 'y' : '')\n    ].join('')\n  }\n\n  var _cbSplit = function (string, sep) {\n    // If separator `s` is not a regex, use the native `split`\n    if (!(sep instanceof RegExp)) {\n      // Had problems to get it to work here using prototype test\n      return String.prototype.split.apply(string, arguments)\n    }\n    var str = String(string)\n    var output = []\n    var lastLastIndex = 0\n    var match\n    var lastLength\n    var limit = Infinity\n    var x = sep._xregexp\n    // This is required if not `s.global`, and it avoids needing to set `s.lastIndex` to zero\n    // and restore it to its original value when we're done using the regex\n    // Brett paring down\n    var s = new RegExp(sep.source, _getNativeFlags(sep) + 'g')\n    if (x) {\n      s._xregexp = {\n        source: x.source,\n        captureNames: x.captureNames ? x.captureNames.slice(0) : null\n      }\n    }\n\n    while ((match = s.exec(str))) {\n      // Run the altered `exec` (required for `lastIndex` fix, etc.)\n      if (s.lastIndex > lastLastIndex) {\n        output.push(str.slice(lastLastIndex, match.index))\n\n        if (match.length > 1 && match.index < str.length) {\n          Array.prototype.push.apply(output, match.slice(1))\n        }\n\n        lastLength = match[0].length\n        lastLastIndex = s.lastIndex\n\n        if (output.length >= limit) {\n          break\n        }\n      }\n\n      if (s.lastIndex === match.index) {\n        s.lastIndex++\n      }\n    }\n\n    if (lastLastIndex === str.length) {\n      if (!s.test('') || lastLength) {\n        output.push('')\n      }\n    } else {\n      output.push(str.slice(lastLastIndex))\n    }\n\n    return output.length > limit ? output.slice(0, limit) : output\n  }\n\n  var i = 0\n  var ll = 0\n  var ranges = []\n  var lastLinePos = 0\n  var firstChar = ''\n  var rangeExp = /^@@\\s+-(\\d+),(\\d+)\\s+\\+(\\d+),(\\d+)\\s+@@$/\n  var lineBreaks = /\\r?\\n/\n  var lines = _cbSplit(patch.replace(/(\\r?\\n)+$/, ''), lineBreaks)\n  var origLines = _cbSplit(originalStr, lineBreaks)\n  var newStrArr = []\n  var linePos = 0\n  var errors = ''\n  var optTemp = 0 // Both string & integer (constant) input is allowed\n  var OPTS = {\n    // Unsure of actual PHP values, so better to rely on string\n    'XDIFF_PATCH_NORMAL': 1,\n    'XDIFF_PATCH_REVERSE': 2,\n    'XDIFF_PATCH_IGNORESPACE': 4\n  }\n\n  // Input defaulting & sanitation\n  if (typeof originalStr !== 'string' || !patch) {\n    return false\n  }\n  if (!flags) {\n    flags = 'XDIFF_PATCH_NORMAL'\n  }\n\n  if (typeof flags !== 'number') {\n    // Allow for a single string or an array of string flags\n    flags = [].concat(flags)\n    for (i = 0; i < flags.length; i++) {\n      // Resolve string input to bitwise e.g. 'XDIFF_PATCH_NORMAL' becomes 1\n      if (OPTS[flags[i]]) {\n        optTemp = optTemp | OPTS[flags[i]]\n      }\n    }\n    flags = optTemp\n  }\n\n  if (flags & OPTS.XDIFF_PATCH_NORMAL) {\n    for (i = 0, ll = lines.length; i < ll; i++) {\n      ranges = lines[i].match(rangeExp)\n      if (ranges) {\n        lastLinePos = linePos\n        linePos = ranges[1] - 1\n        while (lastLinePos < linePos) {\n          newStrArr[newStrArr.length] = origLines[lastLinePos++]\n        }\n        while (lines[++i] && (rangeExp.exec(lines[i])) === null) {\n          firstChar = lines[i].charAt(0)\n          switch (firstChar) {\n            case '-':\n            // Skip including that line\n              ++linePos\n              break\n            case '+':\n              newStrArr[newStrArr.length] = lines[i].slice(1)\n              break\n            case ' ':\n              newStrArr[newStrArr.length] = origLines[linePos++]\n              break\n            default:\n            // Reconcile with returning errrors arg?\n              throw new Error('Unrecognized initial character in unidiff line')\n          }\n        }\n        if (lines[i]) {\n          i--\n        }\n      }\n    }\n    while (linePos > 0 && linePos < origLines.length) {\n      newStrArr[newStrArr.length] = origLines[linePos++]\n    }\n  } else if (flags & OPTS.XDIFF_PATCH_REVERSE) {\n    // Only differs from above by a few lines\n    for (i = 0, ll = lines.length; i < ll; i++) {\n      ranges = lines[i].match(rangeExp)\n      if (ranges) {\n        lastLinePos = linePos\n        linePos = ranges[3] - 1\n        while (lastLinePos < linePos) {\n          newStrArr[newStrArr.length] = origLines[lastLinePos++]\n        }\n        while (lines[++i] && (rangeExp.exec(lines[i])) === null) {\n          firstChar = lines[i].charAt(0)\n          switch (firstChar) {\n            case '-':\n              newStrArr[newStrArr.length] = lines[i].slice(1)\n              break\n            case '+':\n            // Skip including that line\n              ++linePos\n              break\n            case ' ':\n              newStrArr[newStrArr.length] = origLines[linePos++]\n              break\n            default:\n            // Reconcile with returning errrors arg?\n              throw new Error('Unrecognized initial character in unidiff line')\n          }\n        }\n        if (lines[i]) {\n          i--\n        }\n      }\n    }\n    while (linePos > 0 && linePos < origLines.length) {\n      newStrArr[newStrArr.length] = origLines[linePos++]\n    }\n  }\n\n  if (errorObj) {\n    errorObj.value = errors\n  }\n\n  return newStrArr.join('\\n')\n}\n"]}