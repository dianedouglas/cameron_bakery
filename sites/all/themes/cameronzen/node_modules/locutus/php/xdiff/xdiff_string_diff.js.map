{"version":3,"sources":["../../../src/php/xdiff/xdiff_string_diff.js"],"names":[],"mappings":"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","file":"xdiff_string_diff.js","sourcesContent":["module.exports = function xdiff_string_diff (oldData, newData, contextLines, minimal) { // eslint-disable-line camelcase\n  //  discuss at: http://locutus.io/php/xdiff_string_diff\n  // original by: Brett Zamir (http://brett-zamir.me)\n  //    based on: Imgen Tata (http://www.myipdf.com/)\n  // bugfixed by: Imgen Tata (http://www.myipdf.com/)\n  // improved by: Brett Zamir (http://brett-zamir.me)\n  //      note 1: The minimal argument is not currently supported\n  //   example 1: xdiff_string_diff('', 'Hello world!')\n  //   returns 1: '@@ -0,0 +1,1 @@\\n+Hello world!'\n\n  // (This code was done by Imgen Tata; I have only reformatted for use in Locutus)\n\n  // See http://en.wikipedia.org/wiki/Diff#Unified_format\n  var i = 0\n  var j = 0\n  var k = 0\n  var oriHunkStart\n  var newHunkStart\n  var oriHunkEnd\n  var newHunkEnd\n  var oriHunkLineNo\n  var newHunkLineNo\n  var oriHunkSize\n  var newHunkSize\n  var MAX_CONTEXT_LINES = Number.POSITIVE_INFINITY // Potential configuration\n  var MIN_CONTEXT_LINES = 0\n  var DEFAULT_CONTEXT_LINES = 3\n  var HEADER_PREFIX = '@@ ' //\n  var HEADER_SUFFIX = ' @@'\n  var ORIGINAL_INDICATOR = '-'\n  var NEW_INDICATOR = '+'\n  var RANGE_SEPARATOR = ','\n  var CONTEXT_INDICATOR = ' '\n  var DELETION_INDICATOR = '-'\n  var ADDITION_INDICATOR = '+'\n  var oriLines\n  var newLines\n  var NEW_LINE = '\\n'\n\n  var _trim = function (text) {\n    if (typeof text !== 'string') {\n      throw new Error('String parameter required')\n    }\n\n    return text.replace(/(^\\s*)|(\\s*$)/g, '')\n  }\n\n  var _verifyType = function (type) {\n    var args = arguments\n    var argsLen = arguments.length\n    var basicTypes = ['number', 'boolean', 'string', 'function', 'object', 'undefined']\n    var basicType\n    var i\n    var j\n    var typeOfType = typeof type\n    if (typeOfType !== 'string' && typeOfType !== 'function') {\n      throw new Error('Bad type parameter')\n    }\n\n    if (argsLen < 2) {\n      throw new Error('Too few arguments')\n    }\n\n    if (typeOfType === 'string') {\n      type = _trim(type)\n\n      if (type === '') {\n        throw new Error('Bad type parameter')\n      }\n\n      for (j = 0; j < basicTypes.length; j++) {\n        basicType = basicTypes[j]\n\n        if (basicType === type) {\n          for (i = 1; i < argsLen; i++) {\n            if (typeof args[i] !== type) {\n              throw new Error('Bad type')\n            }\n          }\n\n          return\n        }\n      }\n\n      throw new Error('Bad type parameter')\n    }\n\n    // Not basic type. we need to use instanceof operator\n    for (i = 1; i < argsLen; i++) {\n      if (!(args[i] instanceof type)) {\n        throw new Error('Bad type')\n      }\n    }\n  }\n\n  var _hasValue = function (array, value) {\n    var i\n    _verifyType(Array, array)\n\n    for (i = 0; i < array.length; i++) {\n      if (array[i] === value) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  var _areTypeOf = function (type) {\n    var args = arguments\n    var argsLen = arguments.length\n    var basicTypes = ['number', 'boolean', 'string', 'function', 'object', 'undefined']\n    var basicType\n    var i\n    var j\n    var typeOfType = typeof type\n\n    if (typeOfType !== 'string' && typeOfType !== 'function') {\n      throw new Error('Bad type parameter')\n    }\n\n    if (argsLen < 2) {\n      throw new Error('Too few arguments')\n    }\n\n    if (typeOfType === 'string') {\n      type = _trim(type)\n\n      if (type === '') {\n        return false\n      }\n\n      for (j = 0; j < basicTypes.length; j++) {\n        basicType = basicTypes[j]\n\n        if (basicType === type) {\n          for (i = 1; i < argsLen; i++) {\n            if (typeof args[i] !== type) {\n              return false\n            }\n          }\n\n          return true\n        }\n      }\n\n      throw new Error('Bad type parameter')\n    }\n\n    // Not basic type. we need to use instanceof operator\n    for (i = 1; i < argsLen; i++) {\n      if (!(args[i] instanceof type)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  var _getInitializedArray = function (arraySize, initValue) {\n    var array = []\n    var i\n    _verifyType('number', arraySize)\n\n    for (i = 0; i < arraySize; i++) {\n      array.push(initValue)\n    }\n\n    return array\n  }\n\n  var _splitIntoLines = function (text) {\n    _verifyType('string', text)\n\n    if (text === '') {\n      return []\n    }\n    return text.split('\\n')\n  }\n\n  var _isEmptyArray = function (obj) {\n    return _areTypeOf(Array, obj) && obj.length === 0\n  }\n\n  /**\n   * Finds longest common sequence between two sequences\n   * @see {@link http://wordaligned.org/articles/longest-common-subsequence}\n   */\n  var _findLongestCommonSequence = function (seq1, seq2, seq1IsInLcs, seq2IsInLcs) {\n    if (!_areTypeOf(Array, seq1, seq2)) {\n      throw new Error('Array parameters are required')\n    }\n\n    // Deal with edge case\n    if (_isEmptyArray(seq1) || _isEmptyArray(seq2)) {\n      return []\n    }\n\n    // Function to calculate lcs lengths\n    var lcsLens = function (xs, ys) {\n      var i\n      var j\n      var prev\n      var curr = _getInitializedArray(ys.length + 1, 0)\n\n      for (i = 0; i < xs.length; i++) {\n        prev = curr.slice(0)\n        for (j = 0; j < ys.length; j++) {\n          if (xs[i] === ys[j]) {\n            curr[j + 1] = prev[j] + 1\n          } else {\n            curr[j + 1] = Math.max(curr[j], prev[j + 1])\n          }\n        }\n      }\n\n      return curr\n    }\n\n    // Function to find lcs and fill in the array to indicate the optimal longest common sequence\n    var _findLcs = function (xs, xidx, xIsIn, ys) {\n      var i\n      var xb\n      var xe\n      var llB\n      var llE\n      var pivot\n      var max\n      var yb\n      var ye\n      var nx = xs.length\n      var ny = ys.length\n\n      if (nx === 0) {\n        return []\n      }\n      if (nx === 1) {\n        if (_hasValue(ys, xs[0])) {\n          xIsIn[xidx] = true\n          return [xs[0]]\n        }\n        return []\n      }\n      i = Math.floor(nx / 2)\n      xb = xs.slice(0, i)\n      xe = xs.slice(i)\n      llB = lcsLens(xb, ys)\n      llE = lcsLens(xe.slice(0)\n        .reverse(), ys.slice(0)\n        .reverse())\n\n      pivot = 0\n      max = 0\n      for (j = 0; j <= ny; j++) {\n        if (llB[j] + llE[ny - j] > max) {\n          pivot = j\n          max = llB[j] + llE[ny - j]\n        }\n      }\n      yb = ys.slice(0, pivot)\n      ye = ys.slice(pivot)\n      return _findLcs(xb, xidx, xIsIn, yb).concat(_findLcs(xe, xidx + i, xIsIn, ye))\n    }\n\n    // Fill in seq1IsInLcs to find the optimal longest common subsequence of first sequence\n    _findLcs(seq1, 0, seq1IsInLcs, seq2)\n    // Fill in seq2IsInLcs to find the optimal longest common subsequence\n    // of second sequence and return the result\n    return _findLcs(seq2, 0, seq2IsInLcs, seq1)\n  }\n\n  // First, check the parameters\n  if (_areTypeOf('string', oldData, newData) === false) {\n    return false\n  }\n\n  if (oldData === newData) {\n    return ''\n  }\n\n  if (typeof contextLines !== 'number' ||\n    contextLines > MAX_CONTEXT_LINES ||\n    contextLines < MIN_CONTEXT_LINES) {\n    contextLines = DEFAULT_CONTEXT_LINES\n  }\n\n  oriLines = _splitIntoLines(oldData)\n  newLines = _splitIntoLines(newData)\n  var oriLen = oriLines.length\n  var newLen = newLines.length\n  var oriIsInLcs = _getInitializedArray(oriLen, false)\n  var newIsInLcs = _getInitializedArray(newLen, false)\n  var lcsLen = _findLongestCommonSequence(oriLines, newLines, oriIsInLcs, newIsInLcs).length\n  var unidiff = ''\n\n  if (lcsLen === 0) {\n    // No common sequence\n    unidiff = [\n      HEADER_PREFIX,\n      ORIGINAL_INDICATOR,\n      (oriLen > 0 ? '1' : '0'),\n      RANGE_SEPARATOR,\n      oriLen,\n      ' ',\n      NEW_INDICATOR,\n      (newLen > 0 ? '1' : '0'),\n      RANGE_SEPARATOR,\n      newLen,\n      HEADER_SUFFIX\n    ].join('')\n\n    for (i = 0; i < oriLen; i++) {\n      unidiff += NEW_LINE + DELETION_INDICATOR + oriLines[i]\n    }\n\n    for (j = 0; j < newLen; j++) {\n      unidiff += NEW_LINE + ADDITION_INDICATOR + newLines[j]\n    }\n\n    return unidiff\n  }\n\n  var leadingContext = []\n  var trailingContext = []\n  var actualLeadingContext = []\n  var actualTrailingContext = []\n\n  // Regularize leading context by the contextLines parameter\n  var regularizeLeadingContext = function (context) {\n    if (context.length === 0 || contextLines === 0) {\n      return []\n    }\n\n    var contextStartPos = Math.max(context.length - contextLines, 0)\n\n    return context.slice(contextStartPos)\n  }\n\n  // Regularize trailing context by the contextLines parameter\n  var regularizeTrailingContext = function (context) {\n    if (context.length === 0 || contextLines === 0) {\n      return []\n    }\n\n    return context.slice(0, Math.min(contextLines, context.length))\n  }\n\n  // Skip common lines in the beginning\n  while (i < oriLen && oriIsInLcs[i] === true && newIsInLcs[i] === true) {\n    leadingContext.push(oriLines[i])\n    i++\n  }\n\n  j = i\n  // The index in the longest common sequence\n  k = i\n  oriHunkStart = i\n  newHunkStart = j\n  oriHunkEnd = i\n  newHunkEnd = j\n\n  while (i < oriLen || j < newLen) {\n    while (i < oriLen && oriIsInLcs[i] === false) {\n      i++\n    }\n    oriHunkEnd = i\n\n    while (j < newLen && newIsInLcs[j] === false) {\n      j++\n    }\n    newHunkEnd = j\n\n    // Find the trailing context\n    trailingContext = []\n    while (i < oriLen && oriIsInLcs[i] === true && j < newLen && newIsInLcs[j] === true) {\n      trailingContext.push(oriLines[i])\n      k++\n      i++\n      j++\n    }\n\n    if (k >= lcsLen || // No more in longest common lines\n      trailingContext.length >= 2 * contextLines) {\n      // Context break found\n      if (trailingContext.length < 2 * contextLines) {\n        // It must be last block of common lines but not a context break\n        trailingContext = []\n\n        // Force break out\n        i = oriLen\n        j = newLen\n\n        // Update hunk ends to force output to the end\n        oriHunkEnd = oriLen\n        newHunkEnd = newLen\n      }\n\n      // Output the diff hunk\n\n      // Trim the leading and trailing context block\n      actualLeadingContext = regularizeLeadingContext(leadingContext)\n      actualTrailingContext = regularizeTrailingContext(trailingContext)\n\n      oriHunkStart -= actualLeadingContext.length\n      newHunkStart -= actualLeadingContext.length\n      oriHunkEnd += actualTrailingContext.length\n      newHunkEnd += actualTrailingContext.length\n\n      oriHunkLineNo = oriHunkStart + 1\n      newHunkLineNo = newHunkStart + 1\n      oriHunkSize = oriHunkEnd - oriHunkStart\n      newHunkSize = newHunkEnd - newHunkStart\n\n      // Build header\n      unidiff += [\n        HEADER_PREFIX,\n        ORIGINAL_INDICATOR,\n        oriHunkLineNo,\n        RANGE_SEPARATOR,\n        oriHunkSize,\n        ' ',\n        NEW_INDICATOR,\n        newHunkLineNo,\n        RANGE_SEPARATOR,\n        newHunkSize,\n        HEADER_SUFFIX,\n        NEW_LINE\n      ].join('')\n\n      // Build the diff hunk content\n      while (oriHunkStart < oriHunkEnd || newHunkStart < newHunkEnd) {\n        if (oriHunkStart < oriHunkEnd &&\n          oriIsInLcs[oriHunkStart] === true &&\n          newIsInLcs[newHunkStart] === true) {\n          // The context line\n          unidiff += CONTEXT_INDICATOR + oriLines[oriHunkStart] + NEW_LINE\n          oriHunkStart++\n          newHunkStart++\n        } else if (oriHunkStart < oriHunkEnd && oriIsInLcs[oriHunkStart] === false) {\n          // The deletion line\n          unidiff += DELETION_INDICATOR + oriLines[oriHunkStart] + NEW_LINE\n          oriHunkStart++\n        } else if (newHunkStart < newHunkEnd && newIsInLcs[newHunkStart] === false) {\n          // The additional line\n          unidiff += ADDITION_INDICATOR + newLines[newHunkStart] + NEW_LINE\n          newHunkStart++\n        }\n      }\n\n      // Update hunk position and leading context\n      oriHunkStart = i\n      newHunkStart = j\n      leadingContext = trailingContext\n    }\n  }\n\n  // Trim the trailing new line if it exists\n  if (unidiff.length > 0 && unidiff.charAt(unidiff.length) === NEW_LINE) {\n    unidiff = unidiff.slice(0, -1)\n  }\n\n  return unidiff\n}\n"]}