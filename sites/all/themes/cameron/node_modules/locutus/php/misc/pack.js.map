{"version":3,"sources":["../../../src/php/misc/pack.js"],"names":[],"mappings":"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","file":"pack.js","sourcesContent":["module.exports = function pack (format) {\n  //  discuss at: http://locutus.io/php/pack/\n  // original by: Tim de Koning (http://www.kingsquare.nl)\n  //    parts by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n  // bugfixed by: Tim de Koning (http://www.kingsquare.nl)\n  //      note 1: Float encoding by: Jonas Raoni Soares Silva\n  //      note 1: Home: http://www.kingsquare.nl/blog/12-12-2009/13507444\n  //      note 1: Feedback: phpjs-pack@kingsquare.nl\n  //      note 1: \"machine dependent byte order and size\" aren't\n  //      note 1: applicable for JavaScript; pack works as on a 32bit,\n  //      note 1: little endian machine.\n  //   example 1: pack('nvc*', 0x1234, 0x5678, 65, 66)\n  //   returns 1: '\\u00124xVAB'\n  //   example 2: pack('H4', '2345')\n  //   returns 2: '#E'\n  //   example 3: pack('H*', 'D5')\n  //   returns 3: 'Õ'\n  //   example 4: pack('d', -100.876)\n  //   returns 4: \"\\u0000\\u0000\\u0000\\u0000\\u00008YÀ\"\n  //        test: skip-1\n\n  var formatPointer = 0\n  var argumentPointer = 1\n  var result = ''\n  var argument = ''\n  var i = 0\n  var r = []\n  var instruction, quantifier, word, precisionBits, exponentBits, extraNullCount\n\n  // vars used by float encoding\n  var bias\n  var minExp\n  var maxExp\n  var minUnnormExp\n  var status\n  var exp\n  var len\n  var bin\n  var signal\n  var n\n  var intPart\n  var floatPart\n  var lastBit\n  var rounded\n  var j\n  var k\n  var tmpResult\n\n  while (formatPointer < format.length) {\n    instruction = format.charAt(formatPointer)\n    quantifier = ''\n    formatPointer++\n    while ((formatPointer < format.length) && (format.charAt(formatPointer)\n        .match(/[\\d\\*]/) !== null)) {\n      quantifier += format.charAt(formatPointer)\n      formatPointer++\n    }\n    if (quantifier === '') {\n      quantifier = '1'\n    }\n\n    // Now pack variables: 'quantifier' times 'instruction'\n    switch (instruction) {\n      case 'a':\n      case 'A':\n        // NUL-padded string\n        // SPACE-padded string\n        if (typeof arguments[argumentPointer] === 'undefined') {\n          throw new Error('Warning:  pack() Type ' + instruction + ': not enough arguments')\n        } else {\n          argument = String(arguments[argumentPointer])\n        }\n        if (quantifier === '*') {\n          quantifier = argument.length\n        }\n        for (i = 0; i < quantifier; i++) {\n          if (typeof argument[i] === 'undefined') {\n            if (instruction === 'a') {\n              result += String.fromCharCode(0)\n            } else {\n              result += ' '\n            }\n          } else {\n            result += argument[i]\n          }\n        }\n        argumentPointer++\n        break\n      case 'h':\n      case 'H':\n        // Hex string, low nibble first\n        // Hex string, high nibble first\n        if (typeof arguments[argumentPointer] === 'undefined') {\n          throw new Error('Warning: pack() Type ' + instruction + ': not enough arguments')\n        } else {\n          argument = arguments[argumentPointer]\n        }\n        if (quantifier === '*') {\n          quantifier = argument.length\n        }\n        if (quantifier > argument.length) {\n          var msg = 'Warning: pack() Type ' + instruction + ': not enough characters in string'\n          throw new Error(msg)\n        }\n\n        for (i = 0; i < quantifier; i += 2) {\n          // Always get per 2 bytes...\n          word = argument[i]\n          if (((i + 1) >= quantifier) || typeof argument[i + 1] === 'undefined') {\n            word += '0'\n          } else {\n            word += argument[i + 1]\n          }\n          // The fastest way to reverse?\n          if (instruction === 'h') {\n            word = word[1] + word[0]\n          }\n          result += String.fromCharCode(parseInt(word, 16))\n        }\n        argumentPointer++\n        break\n\n      case 'c':\n      case 'C':\n        // signed char\n        // unsigned char\n        // c and C is the same in pack\n        if (quantifier === '*') {\n          quantifier = arguments.length - argumentPointer\n        }\n        if (quantifier > (arguments.length - argumentPointer)) {\n          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')\n        }\n\n        for (i = 0; i < quantifier; i++) {\n          result += String.fromCharCode(arguments[argumentPointer])\n          argumentPointer++\n        }\n        break\n\n      case 's':\n      case 'S':\n      case 'v':\n        // signed short (always 16 bit, machine byte order)\n        // unsigned short (always 16 bit, machine byte order)\n        // s and S is the same in pack\n        if (quantifier === '*') {\n          quantifier = arguments.length - argumentPointer\n        }\n        if (quantifier > (arguments.length - argumentPointer)) {\n          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')\n        }\n\n        for (i = 0; i < quantifier; i++) {\n          result += String.fromCharCode(arguments[argumentPointer] & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF)\n          argumentPointer++\n        }\n        break\n\n      case 'n':\n        // unsigned short (always 16 bit, big endian byte order)\n        if (quantifier === '*') {\n          quantifier = arguments.length - argumentPointer\n        }\n        if (quantifier > (arguments.length - argumentPointer)) {\n          throw new Error('Warning: pack() Type ' + instruction + ': too few arguments')\n        }\n\n        for (i = 0; i < quantifier; i++) {\n          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] & 0xFF)\n          argumentPointer++\n        }\n        break\n\n      case 'i':\n      case 'I':\n      case 'l':\n      case 'L':\n      case 'V':\n        // signed integer (machine dependent size and byte order)\n        // unsigned integer (machine dependent size and byte order)\n        // signed long (always 32 bit, machine byte order)\n        // unsigned long (always 32 bit, machine byte order)\n        // unsigned long (always 32 bit, little endian byte order)\n        if (quantifier === '*') {\n          quantifier = arguments.length - argumentPointer\n        }\n        if (quantifier > (arguments.length - argumentPointer)) {\n          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')\n        }\n\n        for (i = 0; i < quantifier; i++) {\n          result += String.fromCharCode(arguments[argumentPointer] & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] >> 16 & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] >> 24 & 0xFF)\n          argumentPointer++\n        }\n\n        break\n      case 'N':\n        // unsigned long (always 32 bit, big endian byte order)\n        if (quantifier === '*') {\n          quantifier = arguments.length - argumentPointer\n        }\n        if (quantifier > (arguments.length - argumentPointer)) {\n          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')\n        }\n\n        for (i = 0; i < quantifier; i++) {\n          result += String.fromCharCode(arguments[argumentPointer] >> 24 & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] >> 16 & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] & 0xFF)\n          argumentPointer++\n        }\n        break\n\n      case 'f':\n      case 'd':\n        // float (machine dependent size and representation)\n        // double (machine dependent size and representation)\n        // version based on IEEE754\n        precisionBits = 23\n        exponentBits = 8\n        if (instruction === 'd') {\n          precisionBits = 52\n          exponentBits = 11\n        }\n\n        if (quantifier === '*') {\n          quantifier = arguments.length - argumentPointer\n        }\n        if (quantifier > (arguments.length - argumentPointer)) {\n          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')\n        }\n        for (i = 0; i < quantifier; i++) {\n          argument = arguments[argumentPointer]\n          bias = Math.pow(2, exponentBits - 1) - 1\n          minExp = -bias + 1\n          maxExp = bias\n          minUnnormExp = minExp - precisionBits\n          status = isNaN(n = parseFloat(argument)) || n === -Infinity || n === +Infinity ? n : 0\n          exp = 0\n          len = 2 * bias + 1 + precisionBits + 3\n          bin = new Array(len)\n          signal = (n = status !== 0 ? 0 : n) < 0\n          n = Math.abs(n)\n          intPart = Math.floor(n)\n          floatPart = n - intPart\n\n          for (k = len; k;) {\n            bin[--k] = 0\n          }\n          for (k = bias + 2; intPart && k;) {\n            bin[--k] = intPart % 2\n            intPart = Math.floor(intPart / 2)\n          }\n          for (k = bias + 1; floatPart > 0 && k; --floatPart) {\n            (bin[++k] = ((floatPart *= 2) >= 1) - 0)\n          }\n          for (k = -1; ++k < len && !bin[k];) {}\n\n          // @todo: Make this more readable:\n          var key = (lastBit = precisionBits - 1 +\n            (k =\n              (exp = bias + 1 - k) >= minExp &&\n              exp <= maxExp ? k + 1 : bias + 1 - (exp = minExp - 1))) + 1\n\n          if (bin[key]) {\n            if (!(rounded = bin[lastBit])) {\n              for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]) {}\n            }\n            for (j = lastBit + 1; rounded && --j >= 0;\n            (bin[j] = !bin[j] - 0) && (rounded = 0)) {}\n          }\n\n          for (k = k - 2 < 0 ? -1 : k - 3; ++k < len && !bin[k];) {}\n\n          if ((exp = bias + 1 - k) >= minExp && exp <= maxExp) {\n            ++k\n          } else {\n            if (exp < minExp) {\n              if (exp !== bias + 1 - len && exp < minUnnormExp) {\n                // \"encodeFloat::float underflow\"\n              }\n              k = bias + 1 - (exp = minExp - 1)\n            }\n          }\n\n          if (intPart || status !== 0) {\n            exp = maxExp + 1\n            k = bias + 2\n            if (status === -Infinity) {\n              signal = 1\n            } else if (isNaN(status)) {\n              bin[k] = 1\n            }\n          }\n\n          n = Math.abs(exp + bias)\n          tmpResult = ''\n\n          for (j = exponentBits + 1; --j;) {\n            tmpResult = (n % 2) + tmpResult\n            n = n >>= 1\n          }\n\n          n = 0\n          j = 0\n          k = (tmpResult = (signal ? '1' : '0') + tmpResult + (bin\n            .slice(k, k + precisionBits)\n            .join(''))\n          ).length\n          r = []\n\n          for (; k;) {\n            n += (1 << j) * tmpResult.charAt(--k)\n            if (j === 7) {\n              r[r.length] = String.fromCharCode(n)\n              n = 0\n            }\n            j = (j + 1) % 8\n          }\n\n          r[r.length] = n ? String.fromCharCode(n) : ''\n          result += r.join('')\n          argumentPointer++\n        }\n        break\n\n      case 'x':\n        // NUL byte\n        if (quantifier === '*') {\n          throw new Error('Warning: pack(): Type x: \\'*\\' ignored')\n        }\n        for (i = 0; i < quantifier; i++) {\n          result += String.fromCharCode(0)\n        }\n        break\n\n      case 'X':\n        // Back up one byte\n        if (quantifier === '*') {\n          throw new Error('Warning: pack(): Type X: \\'*\\' ignored')\n        }\n        for (i = 0; i < quantifier; i++) {\n          if (result.length === 0) {\n            throw new Error('Warning: pack(): Type X:' + ' outside of string')\n          } else {\n            result = result.substring(0, result.length - 1)\n          }\n        }\n        break\n\n      case '@':\n        // NUL-fill to absolute position\n        if (quantifier === '*') {\n          throw new Error('Warning: pack(): Type X: \\'*\\' ignored')\n        }\n        if (quantifier > result.length) {\n          extraNullCount = quantifier - result.length\n          for (i = 0; i < extraNullCount; i++) {\n            result += String.fromCharCode(0)\n          }\n        }\n        if (quantifier < result.length) {\n          result = result.substring(0, quantifier)\n        }\n        break\n\n      default:\n        throw new Error('Warning: pack() Type ' + instruction + ': unknown format code')\n    }\n  }\n  if (argumentPointer < arguments.length) {\n    var msg2 = 'Warning: pack(): ' + (arguments.length - argumentPointer) + ' arguments unused'\n    throw new Error(msg2)\n  }\n\n  return result\n}\n"]}